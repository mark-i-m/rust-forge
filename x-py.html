<!DOCTYPE html>
<!-- Page last generated 2018-12-28 19:34:50 +0000 -->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Building rustc with x.py; The Rust Forge</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Rust, Rust programming language, rustlang, rust-lang, Mozilla Rust">
    <meta name="description" content="A systems programming language that runs blazingly fast, prevents segfaults, and guarantees thread safety.">
    <link rel="stylesheet" href="/css/bootstrap.css">
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/forge.css">
    <link rel="stylesheet" href="/rust-forge/css/bootstrap.css">
    <link rel="stylesheet" href="/rust-forge/css/style.css">
    <link rel="stylesheet" href="/rust-forge/css/forge.css">
  </head>

  <body class="container">

    <header>

    <ul class="row menu">
      <li class="col-xs-12 col-md-2">
        <a href="index.html">
	  <!-- FIXME: absolute urls -->
          <img class="img-responsive" src="https://www.rust-lang.org/logos/rust-logo-blk.svg" onerror="this.src='https://www.rust-lang.org/logos/rust-logo-256x256-blk.png'" height="128" width="128" alt="Rust logo" />
        </a>
      </li>
      <li class="col-xs-12 col-md-6 menu">
	<h1>Rust Forge</h1>
      </li>
    </ul>
    </header>

    <div class="content"><h1 id="what-is-xpy">What is <code class="highlighter-rouge">x.py</code>?</h1>

<p><code class="highlighter-rouge">x.py</code> is the script used to orchestrate the tooling in the <code class="highlighter-rouge">rustc</code> repository.
It is the script that can build docs, run tests, and compile <code class="highlighter-rouge">rustc</code>. It is the
now preferred way to build <code class="highlighter-rouge">rustc</code> and it replaces the old makefiles from
before. Below are the different ways to utilize <code class="highlighter-rouge">x.py</code> in order to effectively
deal with the repo for various common tasks.</p>

<h1 id="table-of-contents">Table of Contents</h1>
<ul>
  <li><a href="#building-rustc">Building <code class="highlighter-rouge">rustc</code></a>
    <ul>
      <li><a href="#build-the-compiler">Build the compiler</a></li>
      <li><a href="#build-different-stages">Build different stages</a></li>
      <li><a href="#build-specific-components">Build specific components</a></li>
      <li><a href="#other-flags">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="#testing-rustc">Testing rustc</a>
    <ul>
      <li><a href="#run-all-tests">Run all tests</a></li>
      <li><a href="#run-specific-tests">Run specific tests</a></li>
      <li><a href="#other-flags-2">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="#benchmarking-rust">Benchmarking rustc</a>
    <ul>
      <li><a href="#other-flags-3">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="#documenting-rustc">Documenting rustc</a>
    <ul>
      <li><a href="#document-everything">Document everything</a></li>
      <li><a href="#document-specific-components">Document specific components</a></li>
      <li><a href="#document-internal-rustc-items">Document internal rustc items</a></li>
      <li><a href="#other-flags-4">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="">Cleaning out build directories</a>
    <ul>
      <li><a href="#other-flags-5">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="">Build distribution artifacts</a>
    <ul>
      <li><a href="#other-flags-6">Other Flags</a></li>
    </ul>
  </li>
  <li><a href="">Install distribution artifacts</a>
    <ul>
      <li><a href="#other-flags-7">Other Flags</a></li>
    </ul>
  </li>
</ul>

<h1 id="building-rustc">Building <code class="highlighter-rouge">rustc</code></h1>
<p>If you want to build the compiler to add new features you’ll need to run one of
the build commands. Note that the first time you build the compiler it will take
a longer time to do so since you’ll need to compile the entire LLVM library.
However, subsequent builds won’t be as long unless LLVM is updated.</p>

<h3 id="build-the-compiler">Build the compiler</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py build
</code></pre></div></div>

<p>This command will build the compiler. Because Rust is a bootstrapping compiler
(the Rust compiler is written in Rust) this will involve compiling the compiler
twice. The first compilation creates the “stage 1” compiler and the second
compilation creates the “stage 2” compiler. The “stage 2” compiler is typically
considered the final compiler and is what tests are run with and what you will
likely interact with. In most situations the “stage 1” compiler may be all you
need, but if you’re working on something like procedural macros you’ll need a
“stage 2” compiler. “stage 1” is typically faster for development, while
“stage 2” is the only one guaranteed to work for all tasks.</p>

<p>More often than not this is not the command you want to run unless you plan on
double checking that everything is working.</p>

<h3 id="build-different-stages">Build different stages</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py build <span class="nt">--stage</span> 0

<span class="c"># Stage 1 is typically enough to test out all of your changes</span>
<span class="c"># to the compiler</span>
./x.py build <span class="nt">--stage</span> 1

<span class="c"># Equivalent to ./x.py build</span>
./x.py build <span class="nt">--stage</span> 2
</code></pre></div></div>

<p>You can pass the <code class="highlighter-rouge">--stage</code> flag with what stage you want to build to. It is
recommended that you build to Stage 1 as this is enough to know your changes can
successfully compile and should let you run tests with your changes.</p>

<h3 id="build-specific-components">Build specific components</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Build only the libcore library</span>
./x.py build src/libcore

<span class="c"># Build the libcore and libproc_macro library only</span>
./x.py build src/libcore src/libproc_macro

<span class="c"># Build only libcore up to Stage 1</span>
./x.py build src/libcore <span class="nt">--stage</span> 1
</code></pre></div></div>

<p>Sometimes you might just want to test if the part you’re working on can compile.
Using these commands you can test that it compiles before doing a bigger build
to make sure it works with the compiler. As shown before you can also pass flags
at the end such as <code class="highlighter-rouge">--stage</code></p>

<h3 id="other-flags">Other Flags</h3>

<p>There are other flags you can pass to the build portion of <code class="highlighter-rouge">x.py</code> that can be
beneficial to cutting down compile times or fitting other things you might need
to change. They are:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre></div></div>

<p>Note that the options <code class="highlighter-rouge">--incremental</code>, <code class="highlighter-rouge">--keep-stage 0</code> and <code class="highlighter-rouge">--jobs JOBS</code> can be
used in tandem with <code class="highlighter-rouge">--stage</code> to help reduce build times significantly by
reusing already built components, reusing the first bootstrapped stage, and
running compilation in parallel. To test changes you could run something like:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py build <span class="nt">--stage</span> 1 <span class="nt">--keep-stage</span> 0 <span class="nt">-j</span> 4 <span class="nt">-i</span>
</code></pre></div></div>

<h1 id="testing-rustc">Testing rustc</h1>

<p>If you have successfully built rustc then you’ll need to test that you didn’t
break anything. It’s recommended that you run all of the tests as well as the
tidy script before putting in a PR as this can help you catch errors in your
code as well as enforcing the style guidelines of the repo before submission.</p>

<h3 id="run-all-tests">Run all tests</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py <span class="nb">test</span>
</code></pre></div></div>

<p>Much like <code class="highlighter-rouge">build</code> this will compile all of the tests and run them. This is good to
run right before submission.</p>

<h3 id="run-specific-tests">Run specific tests</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Run only the tidy script</span>
./x.py <span class="nb">test </span>src/tools/tidy

<span class="c"># Run tests on the standard library</span>
./x.py <span class="nb">test </span>src/libstd

<span class="c"># Run tests on the standard library and run the tidy script</span>
./x.py <span class="nb">test </span>src/libstd src/tools/tidy

<span class="c"># Run tests on the standard library using a stage 1 compiler</span>
./x.py <span class="nb">test </span>src/libstd <span class="nt">--stage</span> 1
</code></pre></div></div>

<p>By listing which test suites you want to run you avoid having to run tests for
components you did not change at all.</p>

<h3 id="other-flags-1">Other Flags</h3>

<p>Much like the <code class="highlighter-rouge">build</code> subcommand many of the same flags are still around as well
as a few new ones:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
        --no-fail-fast  Run all tests regardless of failure
        --test-args ARGS
                        extra arguments
</code></pre></div></div>

<p>The last two flags <code class="highlighter-rouge">--no-fail-fast</code> and <code class="highlighter-rouge">--test-args</code> are the extra flags
available for <code class="highlighter-rouge">./x.py test</code> compared to <code class="highlighter-rouge">build</code>.</p>

<h1 id="benchmarking-rustc">Benchmarking rustc</h1>

<p>This one is a easier compared to the others. All you’re doing is
running benchmarks of the compiler itself so it’ll build it and run the one set
of benchmarks available to it. The command is:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py bench
</code></pre></div></div>

<h3 id="other-flags-2">Other Flags</h3>

<p>The <code class="highlighter-rouge">bench</code> option does have flags available to it and they’re shown below.
They’re the same almost as <code class="highlighter-rouge">test</code> and <code class="highlighter-rouge">build</code> but it lacks the <code class="highlighter-rouge">--no-fail-fast</code>
flag that <code class="highlighter-rouge">test</code> has.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
        --test-args ARGS
                        extra arguments
</code></pre></div></div>

<h1 id="documenting-rustc">Documenting rustc</h1>

<p>You might want to build documentation of the various components available like
the standard library. There’s two ways to go about this. You can run <code class="highlighter-rouge">rustdoc</code>
directly on the file to make sure the HTML is correct which is fast or you can
build the documentation as part of the build process through <code class="highlighter-rouge">x.py</code>. Both are
viable methods since documentation is more about the content.</p>

<h3 id="document-everything">Document everything</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Document it all</span>
./x.py doc

<span class="c"># If you want to avoid the whole Stage 2 build</span>
./x.py doc <span class="nt">--stage</span> 1
</code></pre></div></div>

<p>First the compiler and rustdoc get built to make sure everything is okay and
then it documents the files.</p>

<h3 id="document-specific-components">Document specific components</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py doc src/doc/book
./x.py doc src/doc/nomicon
./x.py doc src/doc/book src/libstd
</code></pre></div></div>

<p>Much like individual tests or building certain components you can build only the
documentation you want.</p>

<h3 id="document-internal-rustc-items">Document internal rustc items</h3>

<p>By default <code class="highlighter-rouge">rustc</code> does not build the compiler docs for its internal items.
Mostly because this is useless for the average user. However, you might need to
have it available so you can understand the types. Here’s how you can compile it
yourself. From the top level directory where <code class="highlighter-rouge">x.py</code> is located run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cp config.toml.example config.toml
</code></pre></div></div>

<p>Next open up <code class="highlighter-rouge">config.toml</code> and make sure these two lines are set to true:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docs = true
compiler-docs = true
</code></pre></div></div>

<p>When you want to build the compiler docs as well run this command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py doc
</code></pre></div></div>

<p>This will see that the <code class="highlighter-rouge">docs</code> and <code class="highlighter-rouge">compiler-docs</code> options are set to true and
build the normally hidden compiler docs!</p>

<h3 id="other-flags-3">Other Flags</h3>

<p>Like <code class="highlighter-rouge">build</code>, <code class="highlighter-rouge">doc</code> also has many optional flags available for it to use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre></div></div>

<h1 id="cleaning-out-build-directories">Cleaning out build directories</h1>

<p>Sometimes you need to start fresh, but this is normally not the case. If you
need to run this then <code class="highlighter-rouge">rustbuild</code> is most likely not acting right and you should
file a bug as to what is going wrong. If you do need to clean everything up then 
you only need to run one command!</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py clean
</code></pre></div></div>

<h3 id="other-flags-4">Other Flags</h3>

<p>The same flags from <code class="highlighter-rouge">build</code> are available as well but they’re less effective
here:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre></div></div>

<h1 id="build-distribution-artifacts">Build distribution artifacts</h1>

<p>You might want to build and package up the compiler for distribution. You’ll
want to run this command to do it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py dist
</code></pre></div></div>

<h3 id="other-flags-5">Other Flags</h3>

<p>The same flags from <code class="highlighter-rouge">build</code> are available. You might want to consider adding on
the <code class="highlighter-rouge">-j</code> flag for faster builds when building a distribution artifact.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre></div></div>

<h1 id="install-distribution-artifacts">Install distribution artifacts</h1>
<p>If you’ve built a distribution artifact you might want to install it and test
that it works on your target system. You’ll want to run this command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./x.py install
</code></pre></div></div>

<h3 id="other-flags-6">Other Flags</h3>

<p>The same flags from <code class="highlighter-rouge">build</code> are available as well but they’re less effective
here:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Options:
    -v, --verbose       use verbose output (-vv for very verbose)
    -i, --incremental   use incremental compilation
        --config FILE   TOML configuration file for build
        --build BUILD   build target of the stage0 compiler
        --host HOST     host targets to build
        --target TARGET target targets to build
        --on-fail CMD   command to run on failure
        --stage N       stage to build
        --keep-stage N  stage to keep without recompiling
        --src DIR       path to the root of the rust checkout
    -j, --jobs JOBS     number of jobs to run in parallel
    -h, --help          print this help message
</code></pre></div></div>
</div>

  </body>
</html>
